# -*- coding: utf-8 -*-
"""Pandas Series Fundamentals - Skeleton.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n5jo0EmDLkFKBzqhho6FaFWOawmtVUYu

# 1. DEFINE A PANDAS SERIES (WITH NUMERIC DEFAULT INDEX)
"""

# Pandas is a data manipulation and analysis tool that is built on Numpy.
# Pandas uses a data structure known as DataFrame (think of it as Microsoft excel in Python). 
# DataFrames empower programmers to store and manipulate data in a tabular fashion (rows and columns).
# Series Vs. DataFrame? Series is considered a single column of a DataFrame.

import pandas as pd

# Let's define a Python list that contains 5 stocks: Nvidia, Microsoft, FaceBook, Amazon, and Boeing
my_list = ['NVDA', 'MSFT', 'FB', 'AMZN', 'BA']
my_list

# Let's confirm the Datatype
type(my_list)

# Let's create a one dimensional Pandas "series" 
# Let's use Pandas Constructor Method to create a series from a Python list
# Note that series is formed of data and associated index (numeric index has been automatically generated) 
# Check Pandas Documentation for More information: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas.Series
# Object datatype is used for text data (String)

series_1 = pd.Series(data = my_list)
series_1

# Let's confirm the Pandas Series Datatype
type(series_1)

# Let's define another Pandas Series that contains numeric values (stock prices) instead of text data
# Note that we have int64 datatype which means it's integer stored in 64 bits in memory
series_2 = pd.Series(data = [100, 200, 500, 1000, 2000])
series_2

"""**MINI CHALLENGE #1:**
- **Define a Pandas Series named "my_series" that contains your top 3 favourite movies. Confirm the datatype of "my_series"**
"""

movies_1 = ['Jab We Met', 'Titanic', 'Stranger Things']
movies_series = pd.Series(data = movies_1)
movies_series

type(movies_series)

"""# 2. DEFINE A PANDAS SERIES WITH CUSTOM INDEX"""

# Let's define a Python list that contains 5 stocks: Nvidia, Microsoft, FaceBook, Amazon, and Boeing
list_1 = ['NVDA', 'MSFT', 'FB', 'AMZN', 'BA']

# Let's define a python list as shown below. This python list will be used for the Series index:
lable_1 = ['stock#1', 'stock#2', 'stock#3', 'stock#4', 'stock#5']

# Let's create a one dimensional Pandas "series" 
# Let's use Pandas Constructor Method to create a series from a Python list
# Note that this series is formed of data and associated labels 
series_3 = pd.Series(data = list_1, index = lable_1)

# Let's view the series
series_3

# Let's obtain the datatype
type(series_3)

"""**MINI CHALLENGE #2:**
- **Define a Pandas Series named "my_series" that contains your top 3 favourite movies. Instead of using default numeric indexes (similar to mini challenge #1), use the following indexes "movie #1", "Movie #2", and "movie #3"**
"""

list_2 = ['Jab We Met', 'Titanic', 'Stranger Things']

lable_2 = ['movie #1', 'movie #2', 'movie #3']

series_4 = pd.Series(data = list_2, index = lable_2)
series_4

"""# 3. DEFINE A PANDAS SERIES FROM A DICTIONARY"""

# A Dictionary consists of a collection of key-value pairs. Each key-value pair maps the key to its corresponding value.
# Keys are unique within a dictionary while values may not be. 
# List elements are accessed by their position in the list, via indexing while Dictionary elements are accessed via keys
# Define a dictionary named "my_dict" using key-value pairs

dict_1 = {'Bank client id': 201,
          'Bank client name': 'Shrishti',
          'Net worth (INR)': 45000,
          'Years with bank': 6,}

# Show the dictionary
dict_1

# Confirm the dictionary datatype 
type(dict_1)

# Let's define a Pandas Series Using the dictionary
series_5 = pd.Series(dict_1)
series_5

"""**MINI CHALLENGE #3:**
- **Create a Pandas Series from a dictionary with 3 of your favourite stocks and their corresponding prices** 
"""

my_dict = {'Netflix': 990,
           'AMZN': 1500,
           'MSFT': 1200}

print(my_dict)

series_6 = pd.Series(my_dict)
series_6

"""# 4. PANDAS ATTRIBUTES"""

# Attributes/Properties: do not use parantheses "()" and are used to get Pandas Series Properties. Ex: my_series.values, my_series.shape
# Methods: use parantheses "()" and might include arguments and they actually alter/change the Pandas Series. Ex: my_series.tail(), my_series.head(), my_series.drop_duplicates()
# Indexers: use square brackets "[]" and are used to access specific elements in a Pandas Series or DataFrame. Ex: my_series.loc[], my_series.iloc[]

# Let's redefine a Pandas Series containing our favourite 5 stocks 
# Nvidia, Microsoft, FaceBook, Amazon, and Boeing

list_3 = ['NVDA', 'MSFT', 'FB', 'AMZN', 'BA']
series_7 = pd.Series(data = list_3)
series_7

# ".Values" attribute is used to return Series as ndarray depending on its dtype
# Check this for more information: https://pandas.pydata.org/docs/reference/api/pandas.Series.values.html#pandas.Series.values
series_7.values

# index is used to return the index (axis labels) of the Series
series_7.index

# dtype is used to return the datatype of the Series ('O' stands for 'object' datatype)
series_7.dtype

# Check if all elements are unique or not
series_7.is_unique

# Check the shape of the Series
# note that a Series is one dimensional
series_7.shape

"""**MINI CHALLENGE #4:** 
- **What is the size of the Pandas Series? (External Research for the proper attribute is Required)**
"""

series_7.size

"""# 5. PANDAS METHODS"""

# Methods have parentheses and they actually alter/change the Pandas Series
# Methods: use parantheses "()" and might include arguments. Ex: my_series.tail(), my_series.head(), my_series.drop_duplicates()

# Let's define another Pandas Series that contains numeric values (stock prices) instead of text data
# Note that we have int64 datatype which means it contains integer values stored in 64 bits in memory

series_8 = pd.Series(data = [100, 200, 500, 1000, 5000])
series_8

# Let's obtain the sum of all elements in the Pandas Series
series_8.sum()

# Let's obtain the multiplication of all elements in the Pandas Series
series_8.product()

# Let's obtain the average
series_8.mean()

# Let's show the first couple of elements in the Pandas Series
series_8.head(2)

# Note that head creates a new dataframe 
new_series = series_8.head(3)
new_series

"""**MINI CHALLENGE #5:** 
- **Show the last 2 rows in the Pandas Series (External Research is Required)** 
- **How many bytes does this Pandas Series consume in memory? (External Research is Required)**
"""

series_8.tail(2)

"""# 6. IMPORT CSV DATA (1-D) USING PANDAS"""

# Pandas read_csv is used to read a csv file and store data in a DataFrame by default (DataFrames will be covered shortly!)
# Use Squeeze to convert it into a Pandas Series (One-dimensional)
# Notice that no foramtting exists when a Series is plotted

sp500 = pd.read_csv('C:\Users\Muskaan\OneDrive\Documents\DataAnalytics_Pandas_Numpy_Matplotlib_Seaborn\Datasets\S_P500_Prices.csv', squeeze=True)
sp500

"""**MINI CHALLENGE #6:**
- **Set Squeeze = False and rerun the cell, what do you notice? Use Type to compare both outputs**
"""

sp500_2 = pd.read_csv('C:\Users\Muskaan\OneDrive\Documents\DataAnalytics_Pandas_Numpy_Matplotlib_Seaborn\Datasets\S_P500_Prices.csv', squeeze=False)
sp500_2

type(sp500)

type(sp500_2)

"""# 7. PANDAS BUILT-IN FUNCTIONS"""

# Pandas works great with pre-existing python functions 
# You don't have to play with pandas methods and directly leverage Python functions
# Check Python built-in functions here: https://docs.python.org/3/library/functions.html

sp500 = pd.read_csv('C:\Users\Muskaan\OneDrive\Documents\DataAnalytics_Pandas_Numpy_Matplotlib_Seaborn\Datasets\S_P500_Prices.csv', squeeze=True)
sp500

# Obtain the Data Type of the Pandas Series
type(sp500)

# Obtain the length of the Pandas Series
len(sp500)

# Obtain the maximum value of the Pandas Series
max(sp500)

# Obtain the minimum value of the Pandas Series
min(sp500)

"""**MINI CHALLENGE #7:**
- **Given the following Pandas Series, convert all positive values to negative using python built-in functions**
- **Obtain only unique values (ie: Remove duplicates) using python built-in functions**
- **my_series = pd.Series(data = [-10, 100, -30, 50, 100])**

"""

-abs(sp500)

sp500.is_unique

sp500 = sp500.drop_duplicates()
sp500

sp500.is_unique

"""The real soln"""

my_series = pd.Series(data = [-10, 100, -30, 50, 100])
my_series

abs(my_series)

set(my_series)

"""# 8. SORTING PANDAS SERIES"""

# Let's import CSV data as follows:
sp500_3 = pd.read_csv('C:\Users\Muskaan\OneDrive\Documents\DataAnalytics_Pandas_Numpy_Matplotlib_Seaborn\Datasets\S_P500_Prices.csv', squeeze=True)
sp500_3

# You can sort the values in the dataframe as follows
sp500_3.sort_values()

# Let's view Pandas Series again after sorting, Note that nothing changed in memory! you have to make sure that inplace is set to True
sp500_3

# Set inplace = True to ensure that change has taken place in memory 
sp500_3.sort_values(inplace=True)
sp500_3

# Note that now the change (ordering) took place 
sp500_3

# Notice that the indexes are now changed 
# You can also sort by index (revert back to the original Pandas Series) as follows: 
sp500_3.sort_index(inplace=True)
sp500_3

"""**MINI CHALLENGE #8:**
- **Sort the S&P500 values in a decending order instead. Make sure to update values in-memory.**
"""

sp500_3.sort_values(ascending=False, inplace=True)
sp500_3

"""# 9. PERFORM MATH OPERATIONS ON PANDAS SERIES"""

# Let's import CSV data as follows:
sp500_4 = pd.read_csv('C:\Users\Muskaan\OneDrive\Documents\DataAnalytics_Pandas_Numpy_Matplotlib_Seaborn\Datasets\S_P500_Prices.csv', squeeze=True)
sp500_4

# Apply Sum Method on Pandas Series
sp500_4.sum()

# Apply count Method on Pandas Series
sp500_4.count()

# Obtain the maximum value
sp500_4.max()

# Obtain the minimum value
sp500_4.min()

# My favourite: Describe! 
# Describe is used to obtain all statistical information in one place 

sp500_4.describe()

"""**MINI CHALLENGE #9:**
- **Obtain the average price of the S&P500 using two different methods**
"""

sp500_4.mean()

"""# 10. CHECK IF A GIVEN ELEMENT EXISTS IN A PANDAS SERIES"""

# Let's import CSV data as follows:
sp500_5 = pd.read_csv('C:\Users\Muskaan\OneDrive\Documents\DataAnalytics_Pandas_Numpy_Matplotlib_Seaborn\Datasets\S_P500_Prices.csv', squeeze=True)
sp500_5

# Check if a given number exists in a Pandas Series values
# Returns a boolean "True" or "False"

1295.500000 in sp500_5.values

# Check if a given number exists in a Pandas Series index
32.5 in sp500_5.index

# Note that by default 'in' will search in Pandas index and not values
45 in sp500_5

"""**MINI CHALLENGE #10:**
- **Check if the stock price 3349 exists in the sp500 Pandas Series or not**
- **Round stock prices to the nearest integer and check again**
"""

3349 in sp500_5.values

sp500_5 = round(sp500_5)
sp500_5

3349 in sp500_5.values

"""# 11. INDEXING: OBTAIN SPECIFIC ELEMENTS FROM PANDAS SERIES"""

# Let's import CSV data as follows:

sp500_6 = pd.read_csv('C:\Users\Muskaan\OneDrive\Documents\DataAnalytics_Pandas_Numpy_Matplotlib_Seaborn\Datasets\S_P500_Prices.csv', squeeze=True)
sp500_6

# Obtain the first element in a Pandas Series
# Note that first element has an index 0

sp500_6[0]

sp500_6[200]

# Obtain the last element in the Pandas Series
sp500_6[2158]

"""**MINI CHALLENGE #11:**
- **Obtain the fifth element in the Pandas Series**
"""

sp500_6[4]

"""# 12. SLICING: OBTAIN MULTIPLE ELEMENTS FROM PANDAS SERIES"""

# Let's import CSV data as follows:
sp500 = pd.read_csv('C:\Users\Muskaan\OneDrive\Documents\DataAnalytics_Pandas_Numpy_Matplotlib_Seaborn\Datasets\S_P500_Prices.csv', squeeze=True)
sp500

# Slice elements from a Pandas Series
# Let's obtain elements starting from index 0 up until and not including index 5 (ie: indexes 0-4)

sp500[0:5]

# obtain all elements starting from index 0 up until and not including index 10
sp500[:10]

# obtain all elements starting from index 5 up until the end of the Pandas Series
sp500[5:]

"""**MINI CHALLENGE #12:**
- **Obtain all elements in Pandas Series except for the last 3 elements**
"""

sp500[:-3]

